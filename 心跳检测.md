问题：当TCP两端A、B建立了连接后，如果一端拔掉网线或者拔掉电源，那么另一端能够收到通知吗？ 

答案是不会，但是只有少数人能够正确的回答这个问题。

原因：
--
TCP的建立连接和断开连接都是通过发送数据实现的，也就是我们常说的三次握手、四次挥手。TCP两端保存了一种数据的状态，就代表这种连接，TCP两端之间的路由设备只是将数据转发到目的地，并不知道这些数据实际代表了什么含义，也并没有在其中保存任何的状态信息，也就是说中间的路由设备没有什么连接的概念，只是将数据转发到目的地，只有数据的发送者和接受者两端真正的知道传输的数据代表着一条连接。

但是如果不发送数据那么是无法断开连接的。正常情况下当TCP的一端A调用了SOCKET的close或者进程结束，操作系统就会按照TCP协议发送FIN数据报文。B端收到后就会断开连接。但是当出现了上文所说的异常情况时：A被拔掉网线或者断掉电源，没有机会发出断开的FIN数据报文。而B端没有收到断开的数据报文就会依然保持连接。所以A端拔掉网线或者断掉电源后B端是没办法收到断开连接的通知的。

保持连接并不是毫无代价的，如果这种异常断开的连接有很多，那么势必会耗费大量的资源，必须要想办法检测出这种异常连接。 

解决方案：
---
（1）检测的方法很简单，在应用层，手动地让B端主动通过这个连接向A端继续发送数据即可。上文说过，A端异常断开后，和A端直接连接的路由器是知道的。当B端发送的数据经过转发后到达这个路由器后，必然最终会返回B端一个目的不可达。此时B端立刻就会知道这条连接其实已经异常断开了。 但是B端不可能知道什么时候会出现这种异常，所以B端必须定时发送数据来检测连接是否异常断开。数据的内容无关紧要，任何数据都能达到这个效果。这个数据就是我们经常在TCP编程中所说的心跳检测。

那么是否只是一端向另一端发送心跳就行了呢？显然不行。因为两端都有可能发生异常断开的情况。所以TCP连接的两端必须都向对端发送心跳。

（2）TCP协议本身就提供了一种KEEP_ALIVE的机制来探测对端的存活。TCP协议有一个KEEP_LIVE开关，只要打开这个开关就会定时发送一些数据长度为零的探测心跳包，发送的频率和次数都可以设置，具体的方法在网上搜索tcp keepalive即可，网上有很多文章，这里不再赘述。

发送心跳包或者其他数据包，tcp 服务端如何判断客户端已经断开连接？
---
recv()用来接收客户端传来的数据，recv()小于等于0时，表示客户端异常。但是造成recv<0有两种情况：

（1）服务器程序接收到外部信号时，返回-1。此时 errno = EINTR。//在程序的起始阶段，我们屏蔽掉信号，但是还有部分信号还是屏蔽不掉的。

（2）客户端断开连接

只有当recv()小于等于0时且 errno != EINTR，才判定为客户端退出，close掉csock


在应用层主动发送心跳数据包的方式和TCP协议本身的保活机制有什么区别呢？
---
答：应用层的心跳数据包会耗费更多的带宽，因为TCP协议的保活机制发送的是数据长度为零心跳包，而应用层的心跳数据包长度则必然会大于0。

应用层的心跳数据包可以带一些应用所需要的数据，随应用自己控制，而TCP协议的保活机制则是对于应用层透明的，无法利用心跳携带数据。

为了节省带宽，keep-alive几个小时才发一条检测消息，如果交互系统需要快速监控，那么就自己实现心跳检测！


