主线程中，tcpServe负责accept接收客户端请求；为了应对大量的客户端连接，这里启动4个子线程，每个子线程中构建cellServe，它其中包含一个客户端的集合，比如有10000个客户端连接，则每个cellserve中负责2500个客户端的数据处理；将accept接收到的csock加入到客户端最少的cellserve中，这里就是一个生产者-消费者模式，主线程充当生产者，处理任务子线程充当消费者，需要通过加锁来解决；

对于每个客户端的cSock，把这个sock封装成ClientSock；为了解决网络中的粘包问题，需要在这个类中，自己手动打造一个较大的buf缓冲，每次尽可能多地从内存缓冲中取出数据，提高接收的效率，防止粘包；同时在类中通过添加定时和定量的缓冲发送，来减少调用发送任务线程；还对客户端实现了心跳检测的功能，防止客户端长时间不发消息占用；

在cellServe中，留给上层的tcpServe一个接口启动线程和添加客户端csock，每个cellServe中有个客户端的集合，用select删选出集合中可读以及可写的客户端，接收其发送的信息并回复；对于不活跃的，进行心跳检测，有选择性地剔除客户端；

由于有大量客户端的加入和退出，因此实现了对象池来提高效率；为了保证客户端长期运行，因此实现了内存池来避免内存碎片的产生；


为了记录程序的运行状态，写了一个双缓存的日志系统。
